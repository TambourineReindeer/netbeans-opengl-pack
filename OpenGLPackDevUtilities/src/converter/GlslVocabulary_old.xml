<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<map>
    <entry>
        <string>gl_Position</string>
        <desc>
            <type>vec4</type>
            <category>build-in-var-vert</category>
            <tooltip>must be written from vertex shader</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The variable &lt;i&gt;gl_Position &lt;/i&gt;is available only in the vertex language 
    and is intended for writing the homogeneous vertex position. All 
    executions of a well-formed vertex shader executable must write a value 
    into this variable. It can be written at any time during shader execution. 
    It may also be read back by a vertex shader after being written. This 
    value will be used by primitive assembly, clipping, culling, and other 
    fixed functionality operations that operate on primitives after vertex 
    processing has occurred. Compilers may generate a diagnostic message if 
    they detect &lt;i&gt;gl_Position &lt;/i&gt;is not written, or read before being 
    written, but not all such cases are detectable. Its value is undefined if 
    the vertex shader executable and does not write &lt;i&gt;gl_Position.&lt;/i&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_PointSize</string>
        <desc>
            <type>float</type>
            <category>build-in-var-vert</category>
            <tooltip>may be written from vertex shader</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The variable &lt;i&gt;gl_PointSize &lt;/i&gt;is available only in the vertex language 
    and is intended for a vertex shader to write the size of the point to be 
    rasterized. It is measured in pixels.

    &lt;p&gt;
      If &lt;i&gt;gl_PointSize &lt;/i&gt;or &lt;i&gt;gl_ClipVertex &lt;/i&gt;are not written to, their 
      values are undefined. Any of these variables can be read back by the 
      shader after writing to them, to retrieve what was written. Reading them 
      before writing them results in undefined behavior. If they are written 
      more than once, it is the last value written that is consumed by the 
      subsequent operations. These built-in variables have global scope.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_ClipVertex</string>
        <desc>
            <type>vec4</type>
            <category>build-in-var-vert</category>
            <tooltip>may be written from vertex shader</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The variable &lt;i&gt;gl_ClipVertex &lt;/i&gt;is available only in the vertex language 
    and provides a place for vertex shaders to write the coordinate to be used 
    with the user clipping planes. The user must ensure the clip vertex and 
    user clipping planes are defined in the same coordinate space. User clip 
    planes work properly only under linear transform. It is undefined what 
    happens under non-linear transform.

    &lt;p&gt;
      If &lt;i&gt;gl_PointSize &lt;/i&gt;or &lt;i&gt;gl_ClipVertex &lt;/i&gt;are not written to, their 
      values are undefined. Any of these variables can be read back by the 
      shader after writing to them, to retrieve what was written. Reading them 
      before writing them results in undefined behavior. If they are written 
      more than once, it is the last value written that is consumed by the 
      subsequent operations. These built-in variables have global scope.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_Vertex</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_Normal</string>
        <desc>
            <type>attribute vec3</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_Color</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_SecondaryColor</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord0</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord1</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord2</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord3</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord4</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord5</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord6</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_MultiTexCoord7</string>
        <desc>
            <type>attribute vec4</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_FogCoord</string>
        <desc>
            <type>attribute float</type>
            <category>build-in-var-vert</category>
        </desc>
    </entry>
    <entry>
        <string>gl_FrontColor</string>
        <desc>
            <type>varying vec4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_BackColor</string>
        <desc>
            <type>varying vec4</type>
            <category>build-in-var</category>
            <tooltip>enable GL_VERTEX_PROGRAM_TWO_SIDE</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_FrontSecondaryColor</string>
        <desc>
            <type>varying vec4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_BackSecondaryColor</string>
        <desc>
            <type>varying vec4</type>
            <category>build-in-var</category>
            <tooltip>enable GL_VERTEX_PROGRAM_TWO_SIDE</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_TexCoord</string>
        <desc>
            <type>varying vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var-frag</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    As with all arrays, indices used to subscript &lt;i&gt;gl_TexCoord &lt;/i&gt;must 
    either be an integral constant expressions, or this array must be 
    re-declared by the shader with a size. The size can be at most &lt;i&gt;gl_MaxTextureCoords&lt;/i&gt;. 
    Using indexes close to 0 may aid the implementation in preserving varying 
    resources.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_FragColor</string>
        <desc>
            <type>vec4</type>
            <category>build-in-var-frag</category>
            <tooltip>pixel color</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    If a shader statically assigns a value to &lt;i&gt;gl_FragColor&lt;/i&gt;, it may not 
    assign a value to any element of &lt;i&gt;gl_FragData&lt;/i&gt;. If a shader 
    statically writes a value to any element of &lt;i&gt;gl_FragData&lt;/i&gt;, it may not 
    assign a value to &lt;i&gt;gl_FragColor&lt;/i&gt;. That is, a shader may assign values 
    to either &lt;i&gt;gl_FragColor &lt;/i&gt;or &lt;i&gt;gl_FragData&lt;/i&gt;, but not both. 
    Multiple shaders linked together must also consistently write just one of 
    these variables.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_FragData</string>
        <desc>
            <type>vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var-frag</category>
            <tooltip>INDEX&lt;gl_MaxDrawBuffers</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The variable &lt;i&gt;gl_FragData &lt;/i&gt;is an array. Writing to &lt;i&gt;gl_FragData[n] &lt;/i&gt;specifies 
    the fragment data that will be used by the subsequent fixed functionality 
    pipeline for data &lt;i&gt;n&lt;/i&gt;. If subsequent fixed functionality consumes 
    fragment data and an execution of a fragment shader executable does not 
    write a value to it, then the fragment data consumed is undefined.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_FragDepth</string>
        <desc>
            <type>float</type>
            <category>build-in-var-frag</category>
            <tooltip>pixel depth</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Writing to &lt;i&gt;gl_FragDepth &lt;/i&gt;will establish the depth value for the 
    fragment being processed. If depth buffering is enabled, and no shader 
    writes &lt;i&gt;gl_FragDepth&lt;/i&gt;, then the fixed function value for depth will 
    be used as the fragment&amp;#8217;s depth value. If a shader statically assigns a 
    value to &lt;i&gt;gl_FragDepth&lt;/i&gt;, and there is an execution path through the 
    shader that does not set &lt;i&gt;gl_FragDepth&lt;/i&gt;, then the value of the 
    fragment&amp;#8217;s depth may be undefined for executions of the shader that take 
    that path. That is, if the set of linked fragment shaders statically 
    contain a write to &lt;i&gt;gl_FragDepth&lt;/i&gt;, then it is responsible for always 
    writing it.

    &lt;p&gt;
      (A shader contains a &lt;i&gt;static assignment &lt;/i&gt;to a variable &lt;i&gt;x &lt;/i&gt;if, 
      after pre-processing, the shader contains a statement that would write 
      to &lt;i&gt;x&lt;/i&gt;, whether or not run-time flow of control will cause that 
      statement to be executed.)
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_Color</string>
        <desc>
            <type>varying vec4</type>
            <category>build-in-var-frag</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The values in &lt;i&gt;gl_Color &lt;/i&gt;and &lt;i&gt;gl_SecondaryColor &lt;/i&gt;will be derived 
    automatically by the system from &lt;i&gt;gl_FrontColor, gl_BackColor, 
    gl_FrontSecondaryColor, &lt;/i&gt;and &lt;i&gt;gl_BackSecondaryColor &lt;/i&gt;based on 
    which face is visible. If fixed functionality is used for vertex 
    processing, then &lt;i&gt;gl_FogFragCoord &lt;/i&gt;will either be the z-coordinate of 
    the fragment in eye space, or the interpolation of the fog coordinate, as 
    described in section 3.10 of the OpenGL 1.4 Specification. The &lt;i&gt;gl_TexCoord[] 
    &lt;/i&gt;values are the interpolated &lt;i&gt;gl_TexCoord[] &lt;/i&gt;values from a vertex 
    shader or the texture coordinates of any fixed pipeline based vertex 
    functionality.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_SecondaryColor</string>
        <desc>
            <type>varying vec4</type>
            <category>build-in-var-frag</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The values in &lt;i&gt;gl_Color &lt;/i&gt;and &lt;i&gt;gl_SecondaryColor &lt;/i&gt;will be derived 
    automatically by the system from &lt;i&gt;gl_FrontColor, gl_BackColor, 
    gl_FrontSecondaryColor, &lt;/i&gt;and &lt;i&gt;gl_BackSecondaryColor &lt;/i&gt;based on 
    which face is visible. If fixed functionality is used for vertex 
    processing, then &lt;i&gt;gl_FogFragCoord &lt;/i&gt;will either be the z-coordinate of 
    the fragment in eye space, or the interpolation of the fog coordinate, as 
    described in section 3.10 of the OpenGL 1.4 Specification. The &lt;i&gt;gl_TexCoord[] 
    &lt;/i&gt;values are the interpolated &lt;i&gt;gl_TexCoord[] &lt;/i&gt;values from a vertex 
    shader or the texture coordinates of any fixed pipeline based vertex 
    functionality.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_FogFragCoord</string>
        <desc>
            <type>varying float</type>
            <category>build-in-var</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    For &lt;i&gt;gl_FogFragCoord&lt;/i&gt;, the value written will be used as the &amp;quot;c&amp;quot; 
    value on page 160 of the OpenGL 1.4 Specification by the fixed 
    functionality pipeline. For example, if the z-coordinate of the fragment 
    in eye space is desired as &amp;quot;c&amp;quot;, then that's what the vertex shader 
    executable should write into &lt;i&gt;gl_FogFragCoord&lt;/i&gt;.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_FragCoord</string>
        <desc>
            <type>vec4</type>
            <category>build-in-var-frag</category>
            <tooltip>pixel coordinate (READ ONLY)</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The variable &lt;i&gt;gl_FragCoord &lt;/i&gt;is available as a read-only variable from 
    within fragment shaders and it holds the window relative coordinates x, y, 
    z, and 1/w values for the fragment. If multi-sampling, this value can be 
    for any location within the pixel, or one of the fragment samples. The use 
    of &lt;b&gt;centroid &lt;/b&gt;varyings does not further restrict this value to be 
    inside the current primitive. This value is the result of the fixed 
    functionality that interpolates primitives after vertex processing to 
    generate fragments. The &lt;i&gt;z &lt;/i&gt;component is the depth value that would 
    be used for the fragment&amp;#8217;s depth if no shader contained no writes to &lt;i&gt;gl_FragDepth. 
    &lt;/i&gt;This is useful for invariance if a shader conditionally computes &lt;i&gt;gl_FragDepth 
    &lt;/i&gt;but otherwise wants the fixed functionality fragment depth.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_FrontFacing</string>
        <desc>
            <type>bool</type>
            <category>build-in-var-frag</category>
            <tooltip>(READ ONLY)</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Fragment shaders have access to the read-only built-in variable &lt;i&gt;gl_FrontFacing, 
    &lt;/i&gt;whose value is &lt;b&gt;true &lt;/b&gt;if the fragment belongs to a front-facing 
    primitive. One use of this is to emulate two-sided lighting by selecting 
    one of two colors calculated by a vertex shader.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxVertexUniformComponents</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 512; // ARB_vertex_shader</tooltip>
            <doc>min = 512; // ARB_vertex_shader</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxFragmentUniformComponents</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min =  64;// ARB_fragment_shader</tooltip>
            <doc>min =  64;// ARB_fragment_shader</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxVertexAttribs</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 16; // ARB_vertex_shader</tooltip>
            <doc>min = 16; // ARB_vertex_shader</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxVaryingFloats</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 32; // ARB_vertex_shader</tooltip>
            <doc>min = 32; // ARB_vertex_shader</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxDrawBuffers</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 1; // proposed ARB_draw_buffers</tooltip>
            <doc>min = 1; // proposed ARB_draw_buffers</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxTextureCoords</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min  = 2; // ARB_fragment_program</tooltip>
            <doc>min  = 2; // ARB_fragment_program</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxTextureUnits</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 2; // GL 1.3</tooltip>
            <doc>min = 2; // GL 1.3</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxTextureImageUnits</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 2; // ARB_fragment_shader</tooltip>
            <doc>min = 2; // ARB_fragment_shader</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxVertexTextureImageUnits</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 0; // ARB_vertex_shader</tooltip>
            <doc>min = 0; // ARB_vertex_shader</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxCombinedTextureImageUnits</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 2; // ARB_vertex_shader</tooltip>
            <doc>min = 2; // ARB_vertex_shader</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxLights</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 8; // GL 1.0</tooltip>
            <doc>min = 8; // GL 1.0</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_MaxClipPlanes</string>
        <desc>
            <type>const int</type>
            <category>build-in-var</category>
            <tooltip>min = 6; // GL 1.0</tooltip>
            <doc>min = 6; // GL 1.0</doc>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewMatrix</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewProjectionMatrix</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ProjectionMatrix</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_TextureMatrix</string>
        <desc>
            <type>uniform mat4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewMatrixInverse</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewProjectionMatrixInverse</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ProjectionMatrixInverse</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_TextureMatrixInverse</string>
        <desc>
            <type>uniform mat4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewMatrixTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewProjectionMatrixTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ProjectionMatrixTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_TextureMatrixTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewMatrixInverseTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ModelViewProjectionMatrixInverseTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_ProjectionMatrixInverseTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_TextureMatrixInverseTranspose</string>
        <desc>
            <type>uniform mat4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_NormalMatrix</string>
        <desc>
            <type>uniform mat3</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_NormalScale</string>
        <desc>
            <type>uniform float</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_DepthRangeParameters</string>
        <desc>
            <type>struct</type>
            <arguments>{float near; float far; float diff;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_DepthRange</string>
        <desc>
            <type>uniform gl_DepthRangeParameters</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_FogParameters</string>
        <desc>
            <type>struct</type>
            <arguments>{vec4 color; float density; float start; float end; float scale;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_Fog</string>
        <desc>
            <type>uniform gl_FogParameters</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_LightSourceParameters</string>
        <desc>
            <type>struct</type>
            <arguments>{vec4 ambient; vec4 diffuse; vec4 specular; vec4 position; vec4 halfVector; vec3 spotDirection; float spotExponent; float spotCutoff; float spotCosCutoff; float constantAttenuation; float linearAttenuation; float quadraticAttenuation;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_LightSource</string>
        <desc>
            <type>uniform gl_LightSourceParameters</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxLights</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_LightModelParameters</string>
        <desc>
            <type>struct</type>
            <arguments>{vec4 ambient;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_LightModel</string>
        <desc>
            <type>uniform gl_LightModelParameters</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_LightModelProducts</string>
        <desc>
            <type>struct</type>
            <arguments>{vec4 sceneColor;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_FrontLightModelProduct</string>
        <desc>
            <type>uniform gl_LightModelProducts</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_BackLightModelProduct</string>
        <desc>
            <type>uniform gl_LightModelProducts</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_LightProducts</string>
        <desc>
            <type>struct</type>
            <arguments>{vec4 ambient; vec4 diffuse; vec4 specular;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_FrontLightProduct</string>
        <desc>
            <type>uniform gl_LightProducts</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxLights</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_BackLightProduct</string>
        <desc>
            <type>uniform gl_LightProducts</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxLights</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_MaterialParameters</string>
        <desc>
            <type>struct</type>
            <arguments>{vec4 emission; vec4 ambient; vec4 diffuse; vec4 specular; float shininess;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_FrontMaterial</string>
        <desc>
            <type>uniform gl_MaterialParameters</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_BackMaterial</string>
        <desc>
            <type>uniform gl_MaterialParameters</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_PointParameters</string>
        <desc>
            <type>struct</type>
            <arguments>{float size; float sizeMin; float sizeMax; float fadeThresholdSize; float distanceConstantAttenuation; float distanceLinearAttenuation; float distanceQuadraticAttenuation;}</arguments>
        </desc>
    </entry>
    <entry>
        <string>gl_Point</string>
        <desc>
            <type>uniform gl_PointParameters</type>
            <category>build-in-var</category>
        </desc>
    </entry>
    <entry>
        <string>gl_TextureEnvColor</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureUnits</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ClipPlane</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxClipPlanes</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_EyePlaneS</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_EyePlaneT</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_EyePlaneR</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_EyePlaneQ</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ObjectPlaneS</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ObjectPlaneT</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ObjectPlaneR</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_ObjectPlaneQ</string>
        <desc>
            <type>uniform vec4</type>
            <arguments>[]</arguments>
            <category>build-in-var</category>
            <tooltip>INDEX&lt;gl_MaxTextureCoords</tooltip>
        </desc>
    </entry>
    <entry>
        <string>float</string>
        <desc>
            <category>type</category>
            <tooltip>single floating-point scalar</tooltip>
        </desc>
    </entry>
    <entry>
        <string>vec2</string>
        <desc>
            <category>type</category>
            <tooltip>two component floating-point vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>vec3</string>
        <desc>
            <category>type</category>
            <tooltip>three component floating-point vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>vec4</string>
        <desc>
            <category>type</category>
            <tooltip>four component floating-point vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>int</string>
        <desc>
            <category>type</category>
            <tooltip>signed integer</tooltip>
        </desc>
    </entry>
    <entry>
        <string>ivec2</string>
        <desc>
            <category>type</category>
            <tooltip>two component integer vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>ivec3</string>
        <desc>
            <category>type</category>
            <tooltip>three component integer vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>ivec4</string>
        <desc>
            <category>type</category>
            <tooltip>four component integer vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>bool</string>
        <desc>
            <category>type</category>
            <tooltip>conditional type, taking on values of true or false (also known as boolean)</tooltip>
        </desc>
    </entry>
    <entry>
        <string>bvec2</string>
        <desc>
            <category>type</category>
            <tooltip>two component boolean vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>bvec3</string>
        <desc>
            <category>type</category>
            <tooltip>three component boolean vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>bvec4</string>
        <desc>
            <category>type</category>
            <tooltip>four component boolean vector</tooltip>
        </desc>
    </entry>
    <entry>
        <string>mat2</string>
        <desc>
            <category>type</category>
            <tooltip>2×2 floating-point matrix</tooltip>
        </desc>
    </entry>
    <entry>
        <string>mat3</string>
        <desc>
            <category>type</category>
            <tooltip>3×3 floating-point matrix</tooltip>
        </desc>
    </entry>
    <entry>
        <string>mat4</string>
        <desc>
            <category>type</category>
            <tooltip>4×4 floating-point matrix</tooltip>
        </desc>
    </entry>
    <entry>
        <string>void</string>
        <desc>
            <category>type</category>
            <tooltip>for functions that do not return a value</tooltip>
        </desc>
    </entry>
    <entry>
        <string>sampler1D</string>
        <desc>
            <category>type</category>
            <tooltip>handle for accessing a 1D texture</tooltip>
        </desc>
    </entry>
    <entry>
        <string>sampler2D</string>
        <desc>
            <category>type</category>
            <tooltip>handle for accessing a 2D texture</tooltip>
        </desc>
    </entry>
    <entry>
        <string>sampler3D</string>
        <desc>
            <category>type</category>
            <tooltip>handle for accessing a 3D texture</tooltip>
        </desc>
    </entry>
    <entry>
        <string>samplerCube</string>
        <desc>
            <category>type</category>
            <tooltip>handle for accessing a cube mapped texture</tooltip>
        </desc>
    </entry>
    <entry>
        <string>sampler1DShadow</string>
        <desc>
            <category>type</category>
            <tooltip>handle for accessing a 1D depth texture with comparison</tooltip>
        </desc>
    </entry>
    <entry>
        <string>sampler2DShadow</string>
        <desc>
            <category>type</category>
            <tooltip>handle for accessing a 2D depth texture with comparison</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>uniform</string>
        <desc>
            <category>qualifier</category>
            <tooltip>input to Vertex and Fragment shader from OpenGL or application (READ-ONLY)</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    &lt;nobr&gt;The &lt;b&gt;uniform &lt;/b&gt;qualifier is used to declare global variables 
    whose values are the same across the entire&lt;/nobr&gt; &lt;nobr&gt;primitive being 
    processed. All &lt;b&gt;uniform &lt;/b&gt;variables are read-only and are initialized 
    externally either at link&lt;/nobr&gt; &lt;nobr&gt;time or through the API. The link 
    time initial value is either the value of the variable's initializer, if&lt;/nobr&gt; 
    &lt;nobr&gt;present, or 0 if no initializer is present. Sampler types cannot 
    have initializers.&lt;/nobr&gt;&lt;br&gt;Example declarations are:

    &lt;pre&gt;      &lt;nobr&gt;uniform vec4 lightPosition;&lt;/nobr&gt;
      &lt;nobr&gt;uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time &lt;/nobr&gt;
	&lt;/pre&gt;
    &lt;nobr&gt;The &lt;b&gt;uniform &lt;/b&gt;qualifier can be used with any of the basic data 
    types, or when declaring a variable whose&lt;/nobr&gt; &lt;nobr&gt;type is a 
    structure, or an array of any of these.&lt;/nobr&gt; &lt;nobr&gt;There is an 
    implementation dependent limit on the amount of storage for uniforms that 
    can be used for&lt;/nobr&gt; &lt;nobr&gt;each type of shader and if this is exceeded 
    it will cause a compile-time or link-time error. Uniform&lt;/nobr&gt; &lt;nobr&gt;variables 
    that are declared but not used do not count against this limit. The number 
    of user-defined&lt;/nobr&gt; &lt;nobr&gt;uniform variables and the number of built-in 
    uniform variables that are used within a shader are added&lt;/nobr&gt; &lt;nobr&gt;together 
    to determine whether available uniform storage has been exceeded.&lt;/nobr&gt;

    &lt;p&gt;
      &lt;nobr&gt;If multiple shaders are linked together, then they will share a 
      single global uniform name space. Hence,&lt;/nobr&gt; &lt;nobr&gt;the types and 
      initializers of uniform variables with the same name must match across 
      all shaders that are&lt;/nobr&gt; &lt;nobr&gt;linked into a single executable. It is 
      legal for some shaders to provide an initializer for a particular&lt;/nobr&gt; &lt;nobr&gt;uniform 
      variable, while another shader does not, but all provided initializers 
      must be equal.&lt;/nobr&gt;
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>attribute</string>
        <desc>
            <category>qualifier</category>
            <tooltip>linkage between a vertex shader and OpenGL for per-vertex data (READ-ONLY)</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The &lt;b&gt;attribute &lt;/b&gt;qualifier is used to declare variables that are 
    passed to a vertex shader from OpenGL on a per-vertex basis. It is an 
    error to declare an attribute variable in any type of shader other than a 
    vertex shader. Attribute variables are read-only as far as the vertex 
    shader is concerned. Values for attribute variables are passed to a vertex 
    shader through the OpenGL vertex API or as part of a vertex array. They 
    convey vertex attributes to the vertex shader and are expected to change 
    on every vertex shader run. The attribute qualifier can be used only with &lt;b&gt;float, 
    &lt;/b&gt;floating-point vectors, and matrices. Attribute variables cannot be 
    declared as arrays or structures.&lt;br&gt;Example declarations:

    &lt;pre&gt;      attribute vec4 position;
      attribute vec3 normal;
      attribute vec2 texCoord; 
	&lt;/pre&gt;
    All the standard OpenGL vertex attributes have built-in variable names to 
    allow easy integration between user programs and OpenGL vertex functions. 
    See Section 7 &amp;#8220;Built-in Variables&amp;#8221; for a list of the built-in attribute 
    names.

    &lt;p&gt;
      It is expected that graphics hardware will have a small number of fixed 
      locations for passing vertex attributes. Therefore, the OpenGL Shading 
      language defines each non-matrix attribute variable as having space for 
      up to four floating-point values (i.e., a vec4). There is an 
      implementation dependent limit on the number of attribute variables that 
      can be used and if this is exceeded it will cause a link error. 
      (Declared attribute variables that are not used do not count against 
      this limit.) A float attribute counts the same amount against this limit 
      as a vec4, so applications may want to consider packing groups of four 
      unrelated float attributes together into a vec4 to better utilize the 
      capabilities of the underlying hardware. A matrix attribute will use up 
      multiple attribute locations. The number of locations used will equal 
      the number of columns in the matrix.
    &lt;/p&gt;
    &lt;p&gt;
      Attribute variables are required to have global scope, and must be 
      declared outside of function bodies, before their first use.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>varying</string>
        <desc>
            <category>qualifier</category>
            <tooltip>output from Vertex shader (READ/WRITE), interpolated, then input to Fragment shader (READ-ONLY)</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Varying variables provide the interface between the vertex shaders, the 
    fragment shaders, and the fixed functionality between them. Vertex shaders 
    will compute values per vertex (such as color, texture coordinates, etc.) 
    and write them to variables declared with the &lt;b&gt;varying &lt;/b&gt;qualifier. A 
    vertex shader may also read &lt;b&gt;varying &lt;/b&gt;variables, getting back the 
    same values it has written. Reading a &lt;b&gt;varying &lt;/b&gt;variable in a vertex 
    shader returns undefined values if it is read before being written.

    &lt;p&gt;
      By definition, varying variables are set per vertex and are interpolated 
      in a perspective-correct manner over the primitive being rendered. If 
      single-sampling, the value is interpolated to the pixel's center, and 
      the &lt;b&gt;centroid &lt;/b&gt;qualifier, if present, is ignored. If 
      multi-sampling, and &lt;b&gt;varying &lt;/b&gt;is not qualified with &lt;b&gt;centroid&lt;/b&gt;, 
      then the value must be interpolated to the pixel's center, or anywhere 
      within the pixel, or to one of the pixel's samples. If multi-sampling 
      and &lt;b&gt;varying &lt;/b&gt;is qualified with &lt;b&gt;centroid&lt;/b&gt;, then the value 
      must be interpolated to a point that lies in both the pixel and in the 
      primitive being rendered, or to one of the pixel's samples that falls 
      within the primitive. Due to the less regular location of centroids, 
      their derivatives may be less accurate than non-centroid varying 
      variables.
    &lt;/p&gt;
    &lt;p&gt;
      When using the &lt;b&gt;centroid &lt;/b&gt;keyword, it must immediately precede the &lt;b&gt;varying 
      &lt;/b&gt;keyword. A fragment shader may read from varying variables and the 
      value read will be the interpolated value, as a function of the 
      fragment's position within the primitive. A fragment shader can not 
      write to a varying variable.
    &lt;/p&gt;
    &lt;p&gt;
      The type and presence of the &lt;b&gt;centroid &lt;/b&gt;and &lt;b&gt;invariant &lt;/b&gt;qualifiers 
      of varying variables with the same name declared in linked vertex and 
      fragments shaders must match, otherwise the link command will fail. Only 
      those varying variables used (i.e. read) in the fragment shader 
      executable must be written to by the vertex shader executable; declaring 
      superfluous varying variables in a vertex shader is permissible.&lt;br&gt;Varying 
      variables are declared as in the following examples:
    &lt;/p&gt;
    &lt;pre&gt;      varying vec3 normal;
      centroid varying vec2 TexCoord;
      invariant centroid varying vec4 Color;
	&lt;/pre&gt;
    The &lt;b&gt;varying &lt;/b&gt;qualifier can be used only with &lt;b&gt;float&lt;/b&gt;, 
    floating-point vectors, matrices, or arrays of these. Structures cannot be &lt;b&gt;varying&lt;/b&gt;. 
    If no vertex shader executable is active, the fixed functionality pipeline 
    of OpenGL will compute values for the built-in varying variables that will 
    be consumed by the fragment shader executable. Similarly, if no fragment 
    shader executable is active, the vertex shader executable is responsible 
    for computing and writing to the varying variables that are needed for 
    OpenGL&amp;#8217;s fixed functionality fragment pipeline. Varying variables are 
    required to have global scope, and must be declared outside of function 
    bodies, before their first use.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>centroid</string>
        <desc>
            <category>qualifier</category>
            <tooltip>centroid interpolation on multi-sample varyings</tooltip>
        </desc>
    </entry>
    <entry>
        <string>invariant</string>
        <desc>
            <category>qualifier</category>
            <tooltip>ensures all calculations of this variable give identical values across programs</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    To ensure that a particular output variable is invariant, it is necessary 
    to use the &lt;b&gt;invariant &lt;/b&gt;qualifier. It can either be used to qualify a 
    previously declared variable as being invariant

    &lt;pre&gt;      invariant gl_Position; // make existing gl_Position be invariant
      varying vec3 Color;
      invariant Color; // make existing Color be invariant
	&lt;/pre&gt;
    or as part of a declaration when a variable is declared

    &lt;pre&gt;      invariant varying vec3 Color;
    &lt;/pre&gt;
    The invariant qualifier must appear before any storage qualifiers (&lt;b&gt;varying&lt;/b&gt;) 
    when combined with a declaration. Only variables output from a vertex 
    shader can be candidates for invariance. This includes user-defined 
    varying variables, the built-in vertex-side varying variables, and the 
    special vertex variables &lt;i&gt;gl_Position &lt;/i&gt;and &lt;i&gt;gl_PointSize&lt;/i&gt;. For 
    varying variables leaving a vertex shader and coming into a fragment 
    shader with the same name, the &lt;b&gt;invariant &lt;/b&gt;keyword has to be used in 
    both the vertex and fragment shaders. The &lt;b&gt;invariant &lt;/b&gt;keyword can be 
    followed by a comma separated list of previously declared identifiers. All 
    uses of &lt;b&gt;invariant &lt;/b&gt;must be at the global scope, and before any use 
    of the variables being declared as invariant.

    &lt;p&gt;
      To guarantee invariance of a particular output variable across two 
      programs, the following must also be true:
    &lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        The output variable is declared as invariant in both programs.
      &lt;/li&gt;
      &lt;li&gt;
        The same values must be input to all shader input variables consumed 
        by expressions and flow control contributing to the value assigned to 
        the output variable.
      &lt;/li&gt;
      &lt;li&gt;
        The texture formats, texel values, and texture filtering are set the 
        same way for any texture function calls contributing to the value of 
        the output variable.
      &lt;/li&gt;
      &lt;li&gt;
        All input values are all operated on in the same way. All operations 
        in the consuming expressions and any intermediate expressions must be 
        the same, with the same order of operands and same associativity, to 
        give the same order of evaluation. Intermediate variables and 
        functions must be declared as the same type with the same explicit or 
        implicit precision qualifiers. Any control flow affecting the output 
        value must be the same, and any expressions consumed to determine this 
        control flow must also follow these invariance rules.
      &lt;/li&gt;
      &lt;li&gt;
        All the data flow and control flow leading to setting the invariant 
        output variable reside in a single compilation unit.
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
      Essentially, all the data flow and control flow leading to an invariant 
      output must match. Initially, by default, all output variables are 
      allowed to be variant. To force all output variables to be invariant, 
      use the pragma
    &lt;/p&gt;
    &lt;pre&gt; #pragma STDGL invariant(all)&lt;/pre&gt;
    before all declarations in a shader. If this pragma is used after the 
    declaration of any variables or functions, then the set of outputs that 
    behave as invariant is undefined. It is an error to use this pragma in a 
    fragment shader.

    &lt;p&gt;
      Generally, invariance is ensured at the cost of flexibility in 
      optimization, so performance can be degraded by use of invariance. 
      Hence, use of this pragma is intended as a debug aid, to avoid 
      individually declaring all output variables as invariant.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>const</string>
        <desc>
            <category>qualifier</category>
            <tooltip>a compile-time constant, or a function parameter that is read-only</tooltip>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    &lt;nobr&gt;Named compile-time constants can be declared using the &lt;b&gt;const &lt;/b&gt;qualifier. 
    Any variables qualified as&lt;/nobr&gt; &lt;nobr&gt;constant are read-only variables 
    for that shader. Declaring variables as constant allows more descriptive&lt;/nobr&gt; 
    &lt;nobr&gt;shaders than using hard-wired numerical constants. The &lt;b&gt;const &lt;/b&gt;qualifier 
    can be used with any of the basic&lt;/nobr&gt; &lt;nobr&gt;data types. It is an error 
    to write to a &lt;b&gt;const &lt;/b&gt;variable outside of its declaration, so they 
    must be initialized&lt;/nobr&gt; when declared.&lt;br&gt;For example,

    &lt;pre&gt;      &lt;nobr&gt;const vec3 zAxis = vec3 (0.0, 0.0, 1.0);&lt;/nobr&gt;
	&lt;/pre&gt;
    &lt;nobr&gt;Structure fields may not be qualified with &lt;b&gt;const&lt;/b&gt;. Structure 
    variables can be declared as &lt;b&gt;const&lt;/b&gt;, and&lt;/nobr&gt; &lt;nobr&gt;initialized 
    with a structure constructor.&lt;/nobr&gt; &lt;nobr&gt;Initializers for const 
    declarations must be constant expressions.&lt;/nobr&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>in</string>
        <desc>
            <category>qualifier</category>
            <tooltip>value initialized on entry, not copied on return (default)</tooltip>
        </desc>
    </entry>
    <entry>
        <string>out</string>
        <desc>
            <category>qualifier</category>
            <tooltip>copied out on return, but not initialized</tooltip>
        </desc>
    </entry>
    <entry>
        <string>inout</string>
        <desc>
            <category>qualifier</category>
            <tooltip>value initialized on entry, and copied out on return</tooltip>
        </desc>
    </entry>
    <entry>
        <string>const</string>
        <desc>
            <category>qualifier</category>
            <tooltip>constant function input</tooltip>
        </desc>
    </entry>
    <entry>
        <string>sin</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The standard trigonometric sine function. Angle in radians.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>cos</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The standard trigonometric cosine function. Angle in radians.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>tan</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The standard trigonometric tangent function. Angle in radians.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>asin</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Arc sine. Returns an angle whose sine is x. The range of values returned 
    by this function is [- Pi / 2 , Pi / 2 ] Results are undefined if |x| &amp;gt; 1.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>acos</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Arc cosine. Returns an angle whose cosine is x. The range of values 
    returned by this function is [0, pi]. Results are undefined if |x|&amp;gt;1.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>atan</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Arc tangent. Returns an angle whose tangent is y_over_x. The range of 
    values returned by this function is [-Pi/2 , Pi/2 ] .
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>atan</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y 
    are used to determine what quadrant the angle is in. The range of values 
    returned by this function is [-Pi, Pi]. Results are undefined if x and y 
    are both 0.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>radians</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Converts degrees to radians, i.e. pi / 180 * degrees
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>degrees</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Converts radians to degrees, i.e. 180/Pi * radians
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>pow</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>exp</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>log</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>exp2</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>log2</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>sqrt</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>inversesqrt</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>abs</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Returns x if x &amp;gt;= 0, otherwise it returns -x
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>ceil</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>clamp</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>clamp</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float, float)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>floor</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>fract</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>max</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>max</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>min</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>min</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>mix</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>mix</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4, float)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>mod</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>mod</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>sign</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>smoothstep</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>smoothstep</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float, float, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>step</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>step</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>ftransform</string>
        <desc>
            <type>vec4</type>
            <arguments>()</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>cross</string>
        <desc>
            <type>vec3</type>
            <arguments>(vec3, vec3)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>distance</string>
        <desc>
            <type>float</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>dot</string>
        <desc>
            <type>float</type>
            <arguments>(float|vec2|vec3|vec4, float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>faceforward</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4 V, float|vec2|vec3|vec4 I, float|vec2|vec3|vec4 N)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>length</string>
        <desc>
            <type>float</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>normalize</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>reflect</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4 I, float|vec2|vec3|vec4 N)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>refract</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4 I, float|vec2|vec3|vec4 M, float eta)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>dFdx</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>dFdy</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>fwidth</string>
        <desc>
            <type>float|vec2|vec3|vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>matrixCompMult</string>
        <desc>
            <type>mat2|mat3|mat4</type>
            <arguments>(mat2|mat3|mat4, mat2|mat3|mat4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>all</string>
        <desc>
            <type>bool</type>
            <arguments>(bvec2|bvec3|bvec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>any</string>
        <desc>
            <type>bool</type>
            <arguments>(bvec2|bvec3|bvec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>equal</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(vec2|vec3|vec4, vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>equal</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(ivec2|ivec3|ivec4, ivec2|ivec3|ivec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>equal</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(bvec2|bvec3|bvec4, bvec2|bvec3|bvec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>greaterThan</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(vec2|vec3|vec4, vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>greaterThan</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(ivec2|ivec3|ivec4, ivec2|ivec3|ivec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>greaterThanEqual</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(vec2|vec3|vec4, vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>greaterThanEqual</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(ivec2|ivec3|ivec4, ivec2|ivec3|ivec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>lessThan</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(vec2|vec3|vec4, vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>lessThan</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(ivec2|ivec3|ivec4, ivec2|ivec3|ivec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>lessThanEqual</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(vec2|vec3|vec4, vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>lessThanEqual</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(ivec2|ivec3|ivec4, ivec2|ivec3|ivec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>not</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(bvec2|bvec3|bvec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>notEqual</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(vec2|vec3|vec4, vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>notEqual</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(ivec2|ivec3|ivec4, ivec2|ivec3|ivec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>notEqual</string>
        <desc>
            <type>bvec2|bvec3|bvec4</type>
            <arguments>(bvec2|bvec3|bvec4, bvec2|bvec3|bvec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture1D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1D, float)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture1D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1D, float, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture1DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1D, vec2|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture1DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1D, vec2|vec4, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture2D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2D, vec2)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture2D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2D, vec2, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture2DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2D, vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture2DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2D, vec3|vec4, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture3D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler3D, vec3)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture3D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler3D, vec3, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture3DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler3D, vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture3DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler3D, vec4, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>textureCube</string>
        <desc>
            <type>vec4</type>
            <arguments>(samplerCube, vec3)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>textureCube</string>
        <desc>
            <type>vec4</type>
            <arguments>(samplerCube, vec3, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow1D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1DShadow, vec3)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow1D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1DShadow, vec3, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow2D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2DShadow, vec3)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow2D</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2DShadow, vec3, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow1DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1DShadow, vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow1DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1DShadow, vec4, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow2DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2DShadow, vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow2DProj</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2DShadow, vec4, float bias)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture1DLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1D, float, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture1DProjLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1D, vec2|vec4, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture2DLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2D, vec2, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture2DProjLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2D, vec3|vec4, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>texture3DProjLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler3D, vec4, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>textureCubeLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(samplerCube, vec3, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow1DLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1DShadow, vec3, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow2DLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2DShadow, vec3, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow1DProjLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler1DShadow, vec4, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>shadow2DProjLod</string>
        <desc>
            <type>vec4</type>
            <arguments>(sampler2DShadow, vec4, float lod)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>noise1</string>
        <desc>
            <type>float</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>noise2</string>
        <desc>
            <type>vec2</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>noise3</string>
        <desc>
            <type>vec3</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>noise4</string>
        <desc>
            <type>vec4</type>
            <arguments>(float|vec2|vec3|vec4)</arguments>
            <category>build-in-func</category>
        </desc>
    </entry>
    <entry>
        <string>break</string>
        <desc>
            <category>jump</category>
        </desc>
    </entry>
    <entry>
        <string>continue</string>
        <desc>
            <category>jump</category>
        </desc>
    </entry>
    <entry>
        <string>do</string>
        <desc>
            <category>iteration</category>
        </desc>
    </entry>
    <entry>
        <string>for</string>
        <desc>
            <category>iteration</category>
        </desc>
    </entry>
    <entry>
        <string>while</string>
        <desc>
            <category>iteration</category>
        </desc>
    </entry>
    <entry>
        <string>if</string>
        <desc>
            <category>selection</category>
        </desc>
    </entry>
    <entry>
        <string>else</string>
        <desc>
            <category>selection</category>
        </desc>
    </entry>
    <entry>
        <string>discard</string>
        <desc>
            <category>jump-frag</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The &lt;b&gt;discard &lt;/b&gt;keyword is only allowed within fragment shaders. It can 
    be used within a fragment shader to abandon the operation on the current 
    fragment. This keyword causes the fragment to be discarded and no updates 
    to any buffers will occur. It would typically be used within a conditional 
    statement, for example:

    &lt;pre&gt;    if (intensity &amp;lt; 0.0)
        discard;
    &lt;/pre&gt;
    A fragment shader may test a fragment&amp;#8217;s alpha value and discard the 
    fragment based on that test. However, it should be noted that coverage 
    testing occurs after the fragment shader runs, and the coverage test can 
    change the alpha value.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>return</string>
        <desc>
            <category>jump</category>
        </desc>
    </entry>
    <entry>
        <string>struct</string>
        <desc>
            <category>keyword</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    Once a structure is defined, and its type is given a name, a constructor 
    is available with the same name to construct instances of that structure. 
    For example:

    &lt;pre&gt; struct light {
	 float intensity;
	 vec3 position;
 }; 
 light lightVar = light(3.0, vec3(1.0, 2.0, 3.0));&lt;/pre&gt;
    The arguments to the constructor will be used to set the structure's 
    fields, in order, using one argument per field. Each argument must be the 
    same type as the field it sets.

    &lt;p&gt;
      Structure constructors can be used as initializers or in expressions.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
    <entry>
        <string>true</string>
        <desc>
            <category>keyword</category>
            <tooltip>boolean value</tooltip>
        </desc>
    </entry>
    <entry>
        <string>false</string>
        <desc>
            <category>keyword</category>
            <tooltip>boolean value</tooltip>
        </desc>
    </entry>
    <entry>
        <string>gl_PointCoord</string>
        <desc>
            <type>vec2</type>
            <category>build-in-var-frag</category>
            <doc>&lt;html&gt;
  &lt;head&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
    The values in &lt;i&gt;gl_PointCoord &lt;/i&gt;are two-dimensional coordinates 
    indicating where within a point primitive the current fragment is located, 
    when point sprites are enabled. They range from 0.0 to 1.0 across the 
    point. If the current primitive is not a point, or if point sprites are 
    not enabled, then the values read from gl_PointCoord are undefined.
  &lt;/body&gt;
&lt;/html&gt;
</doc>
        </desc>
    </entry>
</map>
